## Восстановление кода из SSA-формы

### Теоретическая сводка

Если некоторая переменная имеет N использований и M определений, для представления du- и ud- цепочек понадобится порядка M×N элементов.
Для того, чтобы уменьшить расходы на представление цепочек, можно использовать **SSA (Static Single Assignment form)** — _промежуточное представление, используемое компиляторами, в котором каждой переменной значение присваивается лишь единожды._
Помимо уменьшения затрат на представление цепочек, эта форма имеет и другие преимущества:

• Алгоритмы оптимизации могут быть проще в случае, если переменная имеет только одно определение.

• Для большинства практических программ количество _ϕ_-функций (речь о которых пойдет ниже) растет линейно в зависимости от исходной
программы.

• Несвязанные использования одной переменной (такой, как, например, счетчик двух независимых циклов) получат разные имена в SSA-форме.
Для того, чтобы понять, как выглядит программа в представлении SSA, рассмотрим один базовый блок _B<SUB>i</SUB>_. Пусть блок _B<SUB>i</SUB>_ содержит инструкции, приведенные в левом столбце:

<img src="https://pp.userapi.com/c834100/v834100400/249f2/KmhkAVFX30o.jpg" alt="">

В правом столбце приведено соответствующее им SSA-представление. Рассмотренный пример показывает, что каждое новое присваивание значения переменной на самом деле присваивает значение очередному **поколению** (_generation_). Поколения одной и той же переменной рассматриваются как независимые друг от друга переменные. Описанное преобразование, проведенное в пределах одного базового блока, называют **нумерацией** значений (_value numbering_). Далее, рассмотрим, как привести к SSA-форме код нескольких базовых блоков.

#### Построение SSA-формы

Если инструкции базовых блоков _B<SUB>1</SUB>,...,B<SUB>n</SUB>_ выполняются строго последовательно, то, с точки зрения нашего преобразования, такие блоки можно рассматривать как один большой базовый блок _B_ и применять к нему описанное выше преобразование. Если же есть базовый блок, у которого более одного предка, то становится непонятно, какое поколение переменной необходимо использовать. Чтобы решить проблему, введем специальную нотацию _ϕ_-функций (функций слияния). Необходимо расставить _ϕ_-функции там, где несколько потоков управления сливаются в один. Точнее, пусть у базового блока _B<SUB>i</SUB>_ есть k непосредственных предшественников. Тогда _ϕ_-функция, которую мы разместим в самом начале блока _B<SUB>i</SUB>_, будет иметь _k_ аргументов, причем _m_-ый аргумент будет соответствовать значению переменной, пришедшему по ветви из _m_-того предшественника.

<img src="https://pp.userapi.com/c639127/v639127394/5bf02/LHHewpFubrc.jpg" alt="">

Представление _ϕ_-функций в трехадресном коде выполнено следующим образом:

```c sharp
 case Operation.Phi:
       body = $"{Destination} = {LeftOperand} IF WENT FROM: {RightOperand}";
       break;
```

В начале базового блока соответствующая _ϕ_-функция присваивается новой переменной.



После того, как _ϕ_-функции вставлены, нужно переименовать различные определения переменной _a_ в _a<SUB>1</SUB>,...,a<SUB>m</SUB>_. Будем переименовывать каждое использование переменной _a_, чтобы использовать ближайшее определение d переменной a, которое находится над a в дереве доминирования.

<img src="https://pp.userapi.com/c639127/v639127394/5bf0b/pzIC8lqMimE.jpg" alt="">


### Восстановление из SSA-формы

К сожалению, ϕ-функции не имеют прямого отображения в системы команд современных процессоров, а их непосредственное моделирование достаточно сложно. Следовательно, на одной из фаз оптимизации (до фазы распределения регистров) необходимо устранить из программы все ϕ-функции. Для этого будем руководствоваться следующими соображениями: ϕ-функция в базовом блоке B<SUB>n+1</SUB> имеет n аргументов a<SUB>1</SUB>,...,a<SUB>n</SUB>, если данному базовому блоку непосредственно предшествуют n базовых блоков B<SUB>1</SUB>,...,B<SUB>n</SUB> (n > 1). Пусть ϕ-функция определяет новую переменную a<SUB>n+1</SUB>. Очевидно, что, если управление в блок B<SUB>n+1</SUB> пришло из блока B<SUB>i</SUB>, то ϕ-функцию нужно заменить на присваивание. Поместим такие присваивания в конце всех базовых блоков, непосредственно предшествующих блоку B<SUB>n+1</SUB>. После этого ϕ-функция из блока B<SUB>n+1</SUB> может быть удалена, так как корректное присваивание новой переменной a<SUB>n+1</SUB> будет выполнено на любом пути, ведущим в B<SUB>n+1</SUB>. Чтобы такое преобразование было всегда корректно, перед удалением ϕ-функций необходимо выполнить вспомогательное преобразование графа потока управления, называемое _расщеплением дуг_ (**edge splitting**). Идея этого преобразования проста: пусть есть блок 2, имеющий нескольких предков, и блок 1, который имеет более одного потомка и является предком блока 2. Вставим пустой (не содержащий инструкций) блок между блоками 1 и 2 как показано на рис. 3. В эти пустые блоки будем вставлять инструкции присваивания, как описано выше. Таким образом из кода программы убираются все ϕ-функции, а переменные получают нужные значения.

<img src="https://pp.userapi.com/c639127/v639127394/5bf12/vzz2kdXg25A.jpg" alt="">


