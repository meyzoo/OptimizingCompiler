## Восстановление кода из SSA-формы

### Теоретическая сводка: 

**Определение**
Если некоторая переменная имеет N использований и M определений, для представления du- и ud- цепочек понадобится порядка M×N элементов.
Для того, чтобы уменьшить расходы на представление цепочек, можно использовать *SSA (Static Single Assignment form)* — _промежуточное представление, используемое компиляторами, в котором каждой переменной значение присваивается лишь единожды._
Помимо уменьшения затрат на представление цепочек, эта форма имеет и другие преимущества:

• Алгоритмы оптимизации могут быть проще в случае, если переменная имеет только одно определение.
• Для большинства практических программ количество ϕ-функций (речь о которых пойдет ниже) растет линейно в зависимости от исходной
программы.
• Несвязанные использования одной переменной (такой, как, например, счетчик двух независимых циклов) получат разные имена в SSA-форме.
Для того, чтобы понять, как выглядит программа в представлении SSA, рассмотрим один базовый блок Bi. Пусть блок Bi содержит инструкции, приведенные в левом столбце:

<img src="https://pp.userapi.com/c834100/v834100400/249f2/KmhkAVFX30o.jpg" alt="">

В правом столбце приведено соответствующее им SSA-представление. Рассмотренный пример показывает, что каждое новое присваивание значения переменной на самом деле присваивает значение очередному *поколению* (_generation_). Поколения одной и той же переменной рассматриваются как независимые друг от друга переменные. Описанное преобразование, проведенное в пределах одного базового блока, называют *нумерацией* значений (_value numbering_). Далее, рассмотрим, как привести к SSA-форме код нескольких базовых блоков.

Если инструкции базовых блоков B1,...,Bn выполняются строго последовательно, то, с точки зрения нашего преобразования, такие блоки можно рассматривать как один большой базовый блок B и применять к нему описанное выше преобразование. Если же есть базовый блок, у которого более одного предка, то становится непонятно, какое поколение переменной необходимо использовать. Чтобы решить проблему, введем специальную нотацию ϕ-функций (функций слияния). Необходимо расставить ϕ-функции там, где несколько потоков управления сливаются в один. Точнее, пусть у базового блока Bi есть k непосредственных предшественников. Тогда ϕ-функция, которую мы разместим в самом начале блока Bi, будет иметь k аргументов, причем m-ый аргумент будет соответствовать значению переменной, пришедшему по ветви из m-того предшественника.

image::https://pp.userapi.com/c639127/v639127400/5db6f/jM5BLP_gnfs.jpg[insertPhi]

Далее выработаем критерии, которые позволяют минимизировать количество вставляемых ϕ-функций.

**Критерий слияния путей**

Для переменной a в вершине Z должна быть вставлена ϕ-функция, если выполняются одновременно все следующие условия:

1. Существует блок X, содержащий определение a.
2. Существует блок Y, отличный от X, содержащий определение a. 
3. Существует непустой путь из блока X в блок Z.
4. Существует непустой путь из блока Y в блок Z. 
5. Пути Px,z и Py,z не имеют общих вершин кроме Z.
6. Z не может встречаться сразу в двух этих путях одновременно.

**Критерий границы доминирования**

Пусть B — блок графа потока управления. *Границей доминирования* блока B называется множество блоков, таких, что B доминирует их непосредственных предшественников, но не доминирует сами эти базовые блоки. Критерий границы доминирования выглядит следующим образом: Если блок X содержит определение переменной a, то всякий узел Z на границе доминирования узла X требует ϕ-функции для a. Поскольку ϕ-функция — это тоже определение, то необходимо применять критерий границы доминирования до тех пор, пока ни один блок более не требует вставки ϕ-функции.

Для каждой вершины n нужно найти DF[n] — множество вершин на ее границе.

image::https://pp.userapi.com/c639127/v639127400/5db78/Pidp7q_nCyI.jpg[domination]

image::https://pp.userapi.com/c639127/v639127394/5bef8/9DCx8TM-4Os.jpg[phi]

image::https://pp.userapi.com/c639127/v639127394/5bf02/LHHewpFubrc.jpg[setOfDF]

После того, как ϕ-функции вставлены, можно обойти дерево доминирования и переименовать различные определения переменной a в a1,...,am. Будем переименовывать каждое использование переменной a, чтобы использовать ближайшее определение d переменной a, которое находится над a в дереве доминирования.

image::https://pp.userapi.com/c639127/v639127394/5bf0b/pzIC8lqMimE.jpg[renaming]

**Восстановление из SSA-формы**

К сожалению, ϕ-функции не имеют прямого отображения в системы команд современных процессоров, а их непосредственное моделирование достаточно сложно. Следовательно, на одной из фаз оптимизации (до фазы распределения регистров) необходимо устранить из программы все ϕ-функции. Для этого будем руководствоваться следующими соображениями: ϕ-функция в базовом блоке Bn+1 имеет n аргументов a1,...,an, если данному базовому блоку непосредственно предшествуют n базовых блоков B1,...,Bn (n > 1). Пусть ϕ-функция определяет новую переменную an+1. Очевидно, что, если управление в блок Bn+1 пришло из блока Bi, то ϕ-функцию нужно заменить на присваивание. Поместим такие присваивания в конце всех базовых блоков, непосредственно предшествующих блоку Bn+1. После этого ϕ-функция из блока Bn+1 может быть удалена, так как корректное присваивание новой переменной an+1 будет выполнено на любом пути, ведущим в Bn+1. Чтобы такое преобразование было всегда корректно, перед удалением ϕ-функций необходимо выполнить вспомогательное преобразование графа потока управления, называемое _расщеплением дуг_ (*edge splitting*). Идея этого преобразования проста: пусть есть блок 2, имеющий нескольких предков, и блок 1, который имеет более одного потомка и является предком блока 2. Вставим пустой (не содержащий инструкций) блок между блоками 1 и 2 как показано на рис. 3. В эти пустые блоки будем вставлять инструкции присваивания, как описано выше. Таким образом из кода программы убираются все ϕ-функции, а переменные получают нужные значения.

image::https://pp.userapi.com/c639127/v639127394/5bf12/vzz2kdXg25A.jpg[edgesplitting]
